### Задача 1

*Транзакции требуются в системах баз данных для обработки параллельных изменений. Транзакций можно избежать с помощью
чисто поисковых приложений (только для чтения). Объясните, почему в приложениях, которые также выполняют операции по
изменению, нельзя избежать транзакций для наших читателей. Приведите несколько примеров.*
----
При параллельной записи без транзакций может произойти ситуация, в которой результат одной из транзакций не будет учтён,
или одна транзакция исказит результат другой.

Классический пример:

```
T1: Read (A);
T1: A: = A - N;

T2: Read (A);
T2: A: = A + M;
T2: Write (A);s

T1: Write (A);
T1: Read (B);
T1: B: = B + N;
T1: Write (B);
```

### Задача 2

*Найдите все возможные истории транзакций T1 и T2 и укажите их свойства сериализуемости.*

```
T1:
  Read (A);
  A: = A - N;
  Write (A);
  Read (B);
  B: = B + N;
  Write (B);
T2:
  Read (A);
  A: = A + M;
  Write (A);
```

----
Здесь 15 вариантов, я очевидно не стану их вручную выписывать и рассматривать. Написал для этого скрипт, приложил к
заданию. Принцип проверки на сериализуемость:
1) Сканирую слева направо;
2) Если встретил запись (write), итерируюсь в обратном направлении и проверяю:
   1) Если встретил чтение той же транзакцией, то всё ОК;
   2) Если встретил запись другой транзакцией, то выходит нарушение, серия не сериализуема;
3) Если ошибок не найдено, то серия сериализуема. 

Результат:
1) r1(A), w1(A), r1(B), w1(B), r2(A), w2(A) -> сериализуема
2) r1(A), w1(A), r1(B), r2(A), w1(B), w2(A) -> сериализуема
3) r1(A), w1(A), r1(B), r2(A), w2(A), w1(B) -> сериализуема
4) r1(A), w1(A), r2(A), r1(B), w1(B), w2(A) -> сериализуема
5) r1(A), w1(A), r2(A), r1(B), w2(A), w1(B) -> сериализуема
6) r1(A), w1(A), r2(A), w2(A), r1(B), w1(B) -> сериализуема
7) r1(A), r2(A), w1(A), r1(B), w1(B), w2(A) -> не сериализуема
8) r1(A), r2(A), w1(A), r1(B), w2(A), w1(B) -> не сериализуема
9) r1(A), r2(A), w1(A), w2(A), r1(B), w1(B) -> не сериализуема
10) r1(A), r2(A), w2(A), w1(A), r1(B), w1(B) -> не сериализуема
11) r2(A), r1(A), w1(A), r1(B), w1(B), w2(A) -> не сериализуема
12) r2(A), r1(A), w1(A), r1(B), w2(A), w1(B) -> не сериализуема
13) r2(A), r1(A), w1(A), w2(A), r1(B), w1(B) -> не сериализуема
14) r2(A), r1(A), w2(A), w1(A), r1(B), w1(B) -> не сериализуема
15) r2(A), w2(A), r1(A), w1(A), r1(B), w1(B) -> сериализуема

### Задача 3

Исследуйте транзакции T1, T2, T3, T4, выполняя операции над объектами A, B, C, D, E. Рассмотрим следующие истории:

* H1) r1(A) r2(B) r3(B) r3(C) w2(A) r2(D) r1(A) w1(B) w2(D) r1(A) w2(C) w2(B) r2(B) w3(B) r2(B) c2 w4(C) r4(C) w4(A) c1
  c4 c3
* H2) r1(A) r2(C) w3(D) w1(A) r1(D) w2(A) r2(B) r2(C) w2(B) w3(C) r2(A) w1(B) r1(B) r3(D) w1(B) c1 r3(B) c2 c3
* H3) r1(E) r2(B) r2(A) w2(B) w2(A) w1(B) r2(D) r2(E) r3(E) r2(A) r2(C) w2(A) w2(D) r1(A) w2(C) w1(A) r1(C) r2(E) r3(D)
  r1(A) w3(D) w1(A) r3(A) w1(C) r3(A) w1(B) r3(C) r3(B) r3(C) w3(A) c1 c2 c3
* H4) r3(A) r2(C) r1(B) w1(A) r1(C) r2(A) a1 w2(C) c2 r3(C) c3

Какие истории сериализуемы? Для каждой сериализуемой истории покажите эквивалентную последовательную историю. Как 2PL и
изоляция снапшотов ведут себя в этой последовательности операций? Разрешены ли эти истории? Если да, существуют ли
какие-либо возможные несоответствия с изоляцией снапшотов (snapshot)?

----

### Задача 4

*Можно ли сериализовать следующую историю? Если это так, укажите эквивалентную историю серий. Если нет, скажите,
почему.*

```
T1: Select sum (money) from account;
T2: Insert into account (account#, money) values (123, 0);
T2: Commit;
T1: Select avg (money) from account;
T1: Commit;
```

----
Рассмотрим 2 возможные серии: `T1, T2` и `T2, T1`.

1)

```
T1:
  Select sum (money) from account;
  Select avg (money) from account;
  Commit;
T2:
  Insert into account (account#, money) values (123, 0);
  Commit;
```

Относительно исходной истории здесь меняется порядок вставки и вычисления среднего. Это влияет на результат, среднее
будет иным => это не эквивалентная серия.

2)

```
T2:
  Insert into account (account#, money) values (123, 0);
  Commit;
T1:
  Select sum (money) from account;
  Select avg (money) from account;
  Commit;
```

Относительно исходной истории здесь меняется порядок вставки и вычисления суммы. Это НЕ влияет на результат, так как к
сумме добавится вставленный `money=0` => это эквивалентная серия.

Ответ: можно, эквивалентная серия: `T2, T1`.

### Задача 5

*Объясните, почему ограничения целостности проверяются только в конце транзакции. Какие из свойств ACID требуются при
таком подходе?*

Существует множество операций (последовательностей действий), которые в процессе исполнения просто не могут выполнять
условия целостности. При этом благодаря свойству Atomicity (атомарность) мы можем не требовать условий целостности в
середине транзакции, ведь конечном счёте транзакция либо будет выполнена полностью, либо будет полностью не выполнена.
Таким образом, достаточно требовать соблюдение ограничений целостности до и после транзакции.